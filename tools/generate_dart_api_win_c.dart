// Copyright (c) 2024, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'dart:io';

void main() {
  final dartApiHFile = File('runtime/include/dart_api.h');
  final dartNativeApiHFile = File('runtime/include/dart_native_api.h');
  final dartApiWinCFile = File('runtime/bin/dart_api_win.c');
  final dartApiHContents = dartApiHFile.readAsStringSync();
  final dartNativeApiHContents = dartNativeApiHFile.readAsStringSync();

  final procedureRegexp = RegExp(
    r'(DART_\w+\s+)+(?<returnType>[\w\s\*]+)\s+(?<name>\w+)\((?<arguments>[^)]*)\);',
    multiLine: true,
  );

  final matches = [
    ...procedureRegexp.allMatches(dartApiHContents),
    ...procedureRegexp.allMatches(dartNativeApiHContents),
  ];

  final procedures = <Procedure>[];

  for (final match in matches) {
    final returnType = match.namedGroup('returnType')!;
    final name = match.namedGroup('name')!;
    final argumentsString = match.namedGroup('arguments') ?? '';
    final argumentList =
        argumentsString.split(',').where((arg) => arg != 'void').map((arg) {
          final parts = arg.trim().split(' ');
          return (
            type: parts.sublist(0, parts.length - 1).join(' '),
            name: parts[parts.length - 1],
          );
        }).toList();
    procedures.add((
      name: name,
      returnType: returnType,
      arguments: argumentList,
    ));
  }

  final buffer = StringBuffer();

  buffer.writeln('''
// Copyright (c) 2024, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT. This file is generated by tools/generate_dart_api_win_c.dart.

#include <windows.h>

#include <include/dart_api.h>
#include <include/dart_native_api.h>

''');

  // Generate typedefs for all procedures.
  for (final procedure in procedures) {
    buffer.write('typedef ');
    buffer.write(procedure.returnType);
    buffer.write(' (*');
    buffer.write(procedure.typedefName);
    buffer.write(')(');
    for (final (i, argument) in procedure.arguments.indexed) {
      buffer.write(argument.type);
      if (i < procedure.arguments.length - 1) {
        buffer.write(', ');
      }
    }
    buffer.writeln(');');
  }

  buffer.writeln();

  // Generate function pointers for all procedures.
  for (final procedure in procedures) {
    buffer.write('static ');
    buffer.write(procedure.typedefName);
    buffer.write(' ');
    buffer.write(procedure.functionPointerName);
    buffer.writeln(' = NULL;');
  }

  buffer.writeln();

  // Generate the DllMain function that initializes all function pointers.
  buffer.writeln('''
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
  if (fdwReason == DLL_PROCESS_ATTACH) {
    HMODULE process = GetModuleHandle(NULL);
''');

  for (final procedure in procedures) {
    buffer.write('    ');
    buffer.write(procedure.functionPointerName);
    buffer.write(' = (');
    buffer.write(procedure.typedefName);
    buffer.write(') GetProcAddress(process, "');
    buffer.write(procedure.name);
    buffer.writeln('");');
  }

  buffer.writeln('''
  }

  return TRUE;
}''');

  buffer.writeln();

  // Generate redirecting implementations for all procedures.
  for (final procedure in procedures) {
    final (:name, :returnType, :arguments) = procedure;
    buffer.write(returnType);
    buffer.write(' ');
    buffer.write(name);
    buffer.write('(');
    for (final (i, (:name, :type)) in arguments.indexed) {
      buffer.write(type);
      buffer.write(' ');
      buffer.write(name);
      if (i < arguments.length - 1) {
        buffer.write(', ');
      }
    }
    buffer.writeln(') {');
    buffer.write('  return ');
    buffer.write(procedure.functionPointerName);
    buffer.write('(');
    for (final (i, argument) in arguments.indexed) {
      buffer.write(argument.name);
      if (i < arguments.length - 1) {
        buffer.write(', ');
      }
    }
    buffer.writeln(');');
    buffer.writeln('}');
    buffer.writeln();
  }

  buffer.writeln();

  dartApiWinCFile.writeAsStringSync(buffer.toString());

  // Run clang-format on the generated file.
  final clangFormatResult = Process.runSync('clang-format', [
    '-i',
    dartApiWinCFile.path,
  ]);
  if (clangFormatResult.exitCode != 0) {
    print(clangFormatResult.stdout);
    print(clangFormatResult.stderr);
    exit(1);
  }
}

typedef Procedure =
    ({
      String name,
      String returnType,
      List<({String name, String type})> arguments,
    });

extension on Procedure {
  String get typedefName => '${name}Type';
  String get functionPointerName => '${name}Fn';
}
